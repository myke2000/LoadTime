CCS PCH C Compiler, Version 5.118P, 47857               23-Mar-24 17:49

               Filename:   F:\CSharpProject\LoadTime\NewHeaven_Ser_LCD MOD\Newheaven_UTC_Clock.lst

               ROM used:   2820 bytes (9%)
                           Largest free fragment is 29116
               RAM used:   74 (5%) at main() level
                           78 (5%) worst case
               Stack used: 2 locations
               Stack size: 30

*
0000:  GOTO   09D6
.................... 
....................         #include <Hardware_Setup.h>
....................    
....................      #include <18f4520.h>
.................... //////////// Standard Header file for the PIC18F4520 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4520
0004:  DATA 53,55
0006:  DATA 4E,00
0008:  DATA 4D,4F
000A:  DATA 4E,00
000C:  DATA 54,55
000E:  DATA 45,00
0010:  DATA 57,45
0012:  DATA 44,00
0014:  DATA 54,48
0016:  DATA 55,00
0018:  DATA 46,52
001A:  DATA 49,00
001C:  DATA 53,41
001E:  DATA 54,00
0020:  DATA 4A,41
0022:  DATA 4E,00
0024:  DATA 46,45
0026:  DATA 42,00
0028:  DATA 4D,41
002A:  DATA 52,00
002C:  DATA 41,50
002E:  DATA 52,00
0030:  DATA 4D,41
0032:  DATA 59,00
0034:  DATA 4A,55
0036:  DATA 4E,00
0038:  DATA 4A,55
003A:  DATA 4C,00
003C:  DATA 41,55
003E:  DATA 47,00
0040:  DATA 53,45
0042:  DATA 50,00
0044:  DATA 4F,43
0046:  DATA 54,00
0048:  DATA 4E,4F
004A:  DATA 56,00
004C:  DATA 44,45
004E:  DATA 43,00
0050:  DATA 57,42
0052:  DATA 39,49
0054:  DATA 58,53
0056:  DATA 20,55
0058:  DATA 54,43
005A:  DATA 00,00
005C:  DATA 43,4C
005E:  DATA 4F,43
0060:  DATA 4B,00
0062:  DATA 55,54
0064:  DATA 20,20
0066:  DATA 20,3A
0068:  DATA 20,20
006A:  DATA 00,00
006C:  DATA 43,54
006E:  DATA 20,20
0070:  DATA 20,3A
0072:  DATA 20,20
0074:  DATA 3A,20
0076:  DATA 20,00
0078:  DATA 48,72
007A:  DATA 73,20
007C:  DATA 61,72
007E:  DATA 65,20
0080:  DATA 32,34
0082:  DATA 68,72
0084:  DATA 20,66
0086:  DATA 6F,72
0088:  DATA 6D,61
008A:  DATA 74,00
008C:  DATA 48,72
008E:  DATA 73,20
0090:  DATA 61,72
0092:  DATA 65,20
0094:  DATA 43,54
0096:  DATA 20,74
0098:  DATA 69,6D
009A:  DATA 65,20
009C:  DATA 55,54
009E:  DATA 43,00
00A0:  DATA 74,69
00A2:  DATA 6D,65
00A4:  DATA 20,69
00A6:  DATA 73,20
00A8:  DATA 61,75
00AA:  DATA 74,6F
00AC:  DATA 6D,61
00AE:  DATA 74,69
00B0:  DATA 63,00
00B2:  DATA 20,48
00B4:  DATA 6F,75
00B6:  DATA 72,73
00B8:  DATA 20,3D
00BA:  DATA 2D,3E
00BC:  DATA 20,25
00BE:  DATA 75,00
00C0:  DATA 53,65
00C2:  DATA 63,27
00C4:  DATA 73,20
00C6:  DATA 61,72
00C8:  DATA 65,20
00CA:  DATA 73,65
00CC:  DATA 74,20
00CE:  DATA 74,6F
00D0:  DATA 20,30
00D2:  DATA 20,00
00D4:  DATA 77,68
00D6:  DATA 65,6E
00D8:  DATA 20,6D
00DA:  DATA 69,6E
00DC:  DATA 27,73
00DE:  DATA 20,61
00E0:  DATA 72,65
00E2:  DATA 20,73
00E4:  DATA 61,76
00E6:  DATA 65,64
00E8:  DATA 00,00
00EA:  DATA 20,4D
00EC:  DATA 69,6E
00EE:  DATA 75,74
00F0:  DATA 65,73
00F2:  DATA 20,3D
00F4:  DATA 2D,3E
00F6:  DATA 20,25
00F8:  DATA 75,00
00FA:  DATA 31,3D
00FC:  DATA 53,75
00FE:  DATA 6E,32
0100:  DATA 3D,4D
0102:  DATA 6F,6E
0104:  DATA 33,3D
0106:  DATA 54,75
0108:  DATA 65,34
010A:  DATA 3D,57
010C:  DATA 65,64
010E:  DATA 00,00
0110:  DATA 35,3D
0112:  DATA 54,68
0114:  DATA 75,36
0116:  DATA 3D,46
0118:  DATA 72,69
011A:  DATA 37,3D
011C:  DATA 53,61
011E:  DATA 74,00
0120:  DATA 44,61
0122:  DATA 79,20
0124:  DATA 3D,2D
0126:  DATA 3E,25
0128:  DATA 75,00
012A:  DATA 45,6E
012C:  DATA 74,65
012E:  DATA 72,20
0130:  DATA 6D,6F
0132:  DATA 6E,74
0134:  DATA 68,20
0136:  DATA 31,2D
0138:  DATA 31,32
013A:  DATA 00,00
013C:  DATA 20,4D
013E:  DATA 6F,6E
0140:  DATA 74,68
0142:  DATA 20,3D
0144:  DATA 2D,3E
0146:  DATA 25,75
0148:  DATA 00,00
014A:  DATA 45,6E
014C:  DATA 74,65
014E:  DATA 72,20
0150:  DATA 44,61
0152:  DATA 74,65
0154:  DATA 20,31
0156:  DATA 2D,33
0158:  DATA 31,00
015A:  DATA 20,44
015C:  DATA 61,74
015E:  DATA 65,20
0160:  DATA 3D,2D
0162:  DATA 3E,25
0164:  DATA 75,00
0166:  DATA 48,6F
0168:  DATA 75,72
016A:  DATA 73,2D
016C:  DATA 3E,25
016E:  DATA 75,00
0170:  DATA 20,4D
0172:  DATA 69,6E
0174:  DATA 2D,3E
0176:  DATA 00,00
0178:  DATA 20,20
017A:  DATA 57,42
017C:  DATA 39,49
017E:  DATA 58,53
0180:  DATA 20,55
0182:  DATA 54,43
0184:  DATA 20,43
0186:  DATA 4C,4F
0188:  DATA 43,4B
018A:  DATA 20,20
018C:  DATA 00,00
018E:  DATA 6D,6F
0190:  DATA 6E,74
0192:  DATA 68,20
0194:  DATA 3D,20
0196:  DATA 25,64
0198:  DATA 00,00
019A:  DATA 62,75
019C:  DATA 74,74
019E:  DATA 6F,6E
01A0:  DATA 20,48
01A2:  DATA 49,54
01A4:  DATA 21,21
01A6:  DATA 00,00
*
01D6:  TBLRD*+
01D8:  MOVF   FF5,F
01DA:  BZ    01F6
01DC:  MOVFF  FF6,49
01E0:  MOVFF  FF7,4A
01E4:  MOVF   FF5,W
01E6:  BTFSS  F9E.4
01E8:  BRA    01E6
01EA:  MOVWF  FAD
01EC:  MOVFF  49,FF6
01F0:  MOVFF  4A,FF7
01F4:  BRA    01D6
01F6:  RETURN 0
*
026A:  TBLRD*+
026C:  MOVFF  FF6,4A
0270:  MOVFF  FF7,4B
0274:  MOVF   FF5,W
0276:  BTFSS  F9E.4
0278:  BRA    0276
027A:  MOVWF  FAD
027C:  MOVFF  4A,FF6
0280:  MOVFF  4B,FF7
0284:  DECFSZ 49,F
0286:  BRA    026A
0288:  RETURN 0
028A:  MOVF   4C,W
028C:  CLRF   01
028E:  SUBWF  4B,W
0290:  BC    0298
0292:  MOVFF  4B,00
0296:  BRA    02B0
0298:  CLRF   00
029A:  MOVLW  08
029C:  MOVWF  4D
029E:  RLCF   4B,F
02A0:  RLCF   00,F
02A2:  MOVF   4C,W
02A4:  SUBWF  00,W
02A6:  BTFSC  FD8.0
02A8:  MOVWF  00
02AA:  RLCF   01,F
02AC:  DECFSZ 4D,F
02AE:  BRA    029E
02B0:  RETURN 0
02B2:  MOVF   01,W
02B4:  MOVFF  49,4B
02B8:  MOVLW  64
02BA:  MOVWF  4C
02BC:  RCALL  028A
02BE:  MOVFF  00,49
02C2:  MOVF   01,W
02C4:  MOVLW  30
02C6:  BNZ   02D6
02C8:  BTFSS  4A.1
02CA:  BRA    02E6
02CC:  BTFSC  4A.3
02CE:  BRA    02E6
02D0:  BTFSC  4A.4
02D2:  MOVLW  20
02D4:  BRA    02DC
02D6:  BCF    4A.3
02D8:  BCF    4A.4
02DA:  BSF    4A.0
02DC:  ADDWF  01,F
02DE:  MOVF   01,W
02E0:  BTFSS  F9E.4
02E2:  BRA    02E0
02E4:  MOVWF  FAD
02E6:  MOVFF  49,4B
02EA:  MOVLW  0A
02EC:  MOVWF  4C
02EE:  RCALL  028A
02F0:  MOVFF  00,49
02F4:  MOVF   01,W
02F6:  MOVLW  30
02F8:  BNZ   0306
02FA:  BTFSC  4A.3
02FC:  BRA    0310
02FE:  BTFSS  4A.0
0300:  BRA    0310
0302:  BTFSC  4A.4
0304:  MOVLW  20
0306:  ADDWF  01,F
0308:  MOVF   01,W
030A:  BTFSS  F9E.4
030C:  BRA    030A
030E:  MOVWF  FAD
0310:  MOVLW  30
0312:  ADDWF  49,F
0314:  MOVF   49,W
0316:  BTFSS  F9E.4
0318:  BRA    0316
031A:  MOVWF  FAD
031C:  RETURN 0
.................... 
.................... #list
.................... 
....................      #DEVICE ICD=TRUE
....................      #fuses NOWDT,NOLVP,XT                   
....................      #use delay(crystal=20mHz) 
*
01B0:  CLRF   FEA
01B2:  MOVLW  4A
01B4:  MOVWF  FE9
01B6:  MOVF   FEF,W
01B8:  BZ    01D4
01BA:  MOVLW  06
01BC:  MOVWF  01
01BE:  CLRF   00
01C0:  DECFSZ 00,F
01C2:  BRA    01C0
01C4:  DECFSZ 01,F
01C6:  BRA    01BE
01C8:  MOVLW  7B
01CA:  MOVWF  00
01CC:  DECFSZ 00,F
01CE:  BRA    01CC
01D0:  DECFSZ FEF,F
01D2:  BRA    01BA
01D4:  RETURN 0
....................      #USE RS232 (baud=9600,xmit=pin_c6,rcv=pin_c7,errors,stream=PCdata)
*
01A8:  BTFSS  F9E.4
01AA:  BRA    01A8
01AC:  MOVWF  FAD
01AE:  RETURN 0
*
0252:  BTFSS  F9E.5
0254:  BRA    0252
0256:  MOVFF  FAB,04
025A:  MOVFF  FAE,01
025E:  BTFSS  04.1
0260:  BRA    0266
0262:  BCF    FAB.4
0264:  BSF    FAB.4
0266:  GOTO   0AC4 (RETURN)
....................     //#use rs232(stream=PCdata,UART1,baud=9600)     
....................      #USE I2C(MASTER,I2C1,FORCE_SW,fast=30000)) //100k is max for RTC ds1307
*
031E:  MOVLW  08
0320:  MOVWF  01
0322:  MOVLW  19
0324:  MOVWF  00
0326:  DECFSZ 00,F
0328:  BRA    0326
032A:  BCF    F8B.3
032C:  BCF    F94.3
032E:  MOVLW  19
0330:  MOVWF  00
0332:  DECFSZ 00,F
0334:  BRA    0332
0336:  RLCF   49,F
0338:  BCF    F8B.4
033A:  BTFSC  FD8.0
033C:  BSF    F94.4
033E:  BTFSS  FD8.0
0340:  BCF    F94.4
0342:  BSF    F94.3
0344:  BTFSS  F82.3
0346:  BRA    0344
0348:  DECFSZ 01,F
034A:  BRA    0322
034C:  MOVLW  19
034E:  MOVWF  00
0350:  DECFSZ 00,F
0352:  BRA    0350
0354:  BCF    F8B.3
0356:  BCF    F94.3
0358:  NOP   
035A:  BSF    F94.4
035C:  MOVLW  19
035E:  MOVWF  00
0360:  DECFSZ 00,F
0362:  BRA    0360
0364:  MOVLW  19
0366:  MOVWF  00
0368:  DECFSZ 00,F
036A:  BRA    0368
036C:  BSF    F94.3
036E:  BTFSS  F82.3
0370:  BRA    036E
0372:  CLRF   01
0374:  MOVLW  19
0376:  MOVWF  00
0378:  DECFSZ 00,F
037A:  BRA    0378
037C:  BTFSC  F82.4
037E:  BSF    01.0
0380:  BCF    F8B.3
0382:  BCF    F94.3
0384:  BCF    F8B.4
0386:  BCF    F94.4
0388:  RETURN 0
....................      
....................       
....................       
....................       
....................       
.................... 
....................         #include <RTC_DS1307.h>   // driver for the DS1307 RTC
.................... 
....................   
....................    ///                                                                   /// 
....................    ///                                                                   ///
....................    ///       (0xD0) base address ds1307                                  ///
....................    ///       THIS DRIVER WORKS WITH A DS3231 MODULE ALSO                 ///
....................    ///                                                                   ///
....................    ///                                                                   ///  
....................       
....................               
....................        int8  second, minute, hour, date, month, year, day;
....................        int8  utc_hour;
....................        
....................     void ds1307_display(){
....................      // Convert BCD to decimal
....................         second = (second >> 4) * 10 + (second & 0x0F);
....................         minute = (minute >> 4) * 10 + (minute & 0x0F);
....................         hour =   (hour   >> 4) * 10 + (hour   & 0x0F);
....................         date =   (date   >> 4) * 10 + (date   & 0x0F);
....................         month =  (month  >> 4) * 10 + (month  & 0x0F);
....................         year =   (year   >> 4) * 10 + (year   & 0x0F);
....................      // End conversion
....................      
....................   // ******************************************************
....................   //   THIS SECTION PRINTS THE UTC TIME                   *
....................   // ******************************************************
....................   
....................  //print UTC hrs
....................              utc_hour = hour +6; 
....................              if (hour >17 && hour <25) {utc_hour = hour -18;}
....................           if (utc_hour<10){// add leading zero if hours <10   
....................                 putc (0xfe); 
....................                 putc (0x45); // cursor psn cmd
....................                 putc (0x17); // cursor psn
....................                 printf("0");
....................                 putc (0xfe);  // cursor psn cmd
....................                 putc (0x18);  // put the one's digit of the hours here
....................                 printf ("%u",utc_hour);
....................              } 
....................           if (utc_hour>9){ // if the hours is >10 then no leading zero's       
....................                putc (0xfe); 
....................                putc (0x45); // cursor psn cmd
....................                putc (0x17);  // cursor psn
....................                printf ("%u",utc_hour);
....................              } 
....................      
....................  //print UTC minutes    
....................           if (minute<10){  // add leading zero if hours <10
....................              putc (0xfe);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x1a);  // cursor psn
....................              printf("0");             
....................              putc (0xfe);   
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x1b);  // put the one's digit of the hours here
....................              printf ("%u",minute);
....................              } 
....................           if (minute>9){   // if the hours is >10 then no leading zero's
....................              putc (0xfe);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x1a);  // cursor psn
....................              printf ("%u",minute);
....................              }  
....................         
....................   // ******************************************************
....................   //   THIS SECTION PRINTS THE CURRENT TIME               *
....................   // ******************************************************
....................   
....................  //print CT hrs    
....................           if (hour<10){    // add leading zero if hours <10
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x20);  // cursor psn
....................              printf("0");
....................              putc (0xFE);  // cursor psn
....................              putc (0x23);  // put the one's digit of the hours here
....................              printf ("%u",hour);
....................              } 
....................           if (hour>9){     // if the hours is >10 then no leading zero's
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x20);  // cursor psn
....................              printf ("%u",hour);
....................              } 
....................       
....................  //print CT minutes    
....................           if (minute<10){  // add leading zero if minutes <10
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x23);  // cursor psn
....................              printf("0");
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x24);  // put the one's digit of the minutes here
....................              printf ("%u",minute);
....................              } 
....................           if (minute>9){   // if the minutes is >10 then no leading zero's
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x23);  // cursor psn
....................              printf ("%u",minute);
....................              }   
.................... 
....................  //print seconds 
....................             
....................           if (second<10){  // add leading zero if seconds <10
....................              putc (0xFE);
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x26);  // cursor psn             
....................              printf("0");
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x27);  // put the one's digit of the seconds here
....................              printf ("%u",second);
....................              } 
....................           if (second>9){   // if the seconds is >10 then no leading zero's
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x26);  // cursor psn
....................              printf ("%u",second);
....................              } 
.................... 
....................  //print day
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x59);  // cursor psn
....................              if (day==1){printf ("SUN");}
....................              if (day==2){printf ("MON");}
....................              if (day==3){printf ("TUE");}
....................              if (day==4){printf ("WED");}
....................              if (day==5){printf ("THU");}
....................              if (day==6){printf ("FRI");}
....................              if (day==7){printf ("SAT");}               
....................   //print month
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x5D);  // cursor psn            
....................              if (month==1){printf  ("JAN");}
....................              if (month==2){printf  ("FEB");}
....................              if (month==3){printf  ("MAR");}
....................              if (month==4){printf  ("APR");}
....................              if (month==5){printf  ("MAY");}
....................              if (month==6){printf  ("JUN");}
....................              if (month==7){printf  ("JUL");} 
....................              if (month==8){printf  ("AUG");}
....................              if (month==9){printf  ("SEP");}
....................              if (month==10){printf ("OCT");}
....................              if (month==11){printf ("NOV");}
....................              if (month==12){printf ("DEC");}             
....................   //print date            
....................              putc (0xFE);  
....................              putc (0x45);  // cursor psn cmd
....................              putc (0x60);  // cursor            
....................              printf (" %u  ",date);
....................              
....................        } //END ds1307_display  
....................      
....................     
....................     void write_Seconds()
....................       {
....................        i2c_start();
*
044A:  BSF    F94.4
044C:  MOVLW  19
044E:  MOVWF  00
0450:  DECFSZ 00,F
0452:  BRA    0450
0454:  BSF    F94.3
0456:  MOVLW  19
0458:  MOVWF  00
045A:  DECFSZ 00,F
045C:  BRA    045A
045E:  BCF    F8B.4
0460:  BCF    F94.4
0462:  MOVLW  19
0464:  MOVWF  00
0466:  DECFSZ 00,F
0468:  BRA    0466
046A:  BCF    F8B.3
046C:  BCF    F94.3
....................        i2c_write(0xD0); //base address ds1307
046E:  MOVLW  D0
0470:  MOVWF  49
0472:  RCALL  031E
....................        i2c_write(0);    //seconds address
0474:  CLRF   49
0476:  RCALL  031E
....................        i2c_write(0x00);  //seconds are set to zero (00)
0478:  CLRF   49
047A:  RCALL  031E
....................        i2c_stop();  
047C:  BCF    F94.4
047E:  NOP   
0480:  BSF    F94.3
0482:  BTFSS  F82.3
0484:  BRA    0482
0486:  MOVLW  19
0488:  MOVWF  00
048A:  DECFSZ 00,F
048C:  BRA    048A
048E:  BRA    0490
0490:  NOP   
0492:  BSF    F94.4
0494:  MOVLW  19
0496:  MOVWF  00
0498:  DECFSZ 00,F
049A:  BRA    0498
....................        delay_ms(10);
049C:  MOVLW  0A
049E:  MOVWF  4A
04A0:  RCALL  01B0
04A2:  GOTO   0780 (RETURN)
....................       }
....................      
....................     void Write_Minutes()
....................       {
....................        i2c_start();
*
03EA:  BSF    F94.4
03EC:  MOVLW  19
03EE:  MOVWF  00
03F0:  DECFSZ 00,F
03F2:  BRA    03F0
03F4:  BSF    F94.3
03F6:  MOVLW  19
03F8:  MOVWF  00
03FA:  DECFSZ 00,F
03FC:  BRA    03FA
03FE:  BCF    F8B.4
0400:  BCF    F94.4
0402:  MOVLW  19
0404:  MOVWF  00
0406:  DECFSZ 00,F
0408:  BRA    0406
040A:  BCF    F8B.3
040C:  BCF    F94.3
....................        i2c_write(0xD0);   //base address ds1307
040E:  MOVLW  D0
0410:  MOVWF  49
0412:  RCALL  031E
....................        i2c_write(0x01);   //minutes reg address
0414:  MOVLW  01
0416:  MOVWF  49
0418:  RCALL  031E
....................        i2c_write(minute); //set minutes reg to this value
041A:  MOVFF  06,49
041E:  RCALL  031E
....................        i2c_stop();
0420:  BCF    F94.4
0422:  NOP   
0424:  BSF    F94.3
0426:  BTFSS  F82.3
0428:  BRA    0426
042A:  MOVLW  19
042C:  MOVWF  00
042E:  DECFSZ 00,F
0430:  BRA    042E
0432:  BRA    0434
0434:  NOP   
0436:  BSF    F94.4
0438:  MOVLW  19
043A:  MOVWF  00
043C:  DECFSZ 00,F
043E:  BRA    043C
....................        delay_ms(10);
0440:  MOVLW  0A
0442:  MOVWF  4A
0444:  RCALL  01B0
....................        break;
0446:  GOTO   077E (RETURN)
....................       }
....................      
....................     void Write_Hours()
....................       {
....................        i2c_start();
*
038A:  BSF    F94.4
038C:  MOVLW  19
038E:  MOVWF  00
0390:  DECFSZ 00,F
0392:  BRA    0390
0394:  BSF    F94.3
0396:  MOVLW  19
0398:  MOVWF  00
039A:  DECFSZ 00,F
039C:  BRA    039A
039E:  BCF    F8B.4
03A0:  BCF    F94.4
03A2:  MOVLW  19
03A4:  MOVWF  00
03A6:  DECFSZ 00,F
03A8:  BRA    03A6
03AA:  BCF    F8B.3
03AC:  BCF    F94.3
....................        i2c_write(0xD0); //base address ds1307
03AE:  MOVLW  D0
03B0:  MOVWF  49
03B2:  RCALL  031E
....................        i2c_write(0x02); //hours reg address
03B4:  MOVLW  02
03B6:  MOVWF  49
03B8:  RCALL  031E
....................        i2c_write(hour); //set hours to this value
03BA:  MOVFF  07,49
03BE:  RCALL  031E
....................        i2c_stop();
03C0:  BCF    F94.4
03C2:  NOP   
03C4:  BSF    F94.3
03C6:  BTFSS  F82.3
03C8:  BRA    03C6
03CA:  MOVLW  19
03CC:  MOVWF  00
03CE:  DECFSZ 00,F
03D0:  BRA    03CE
03D2:  BRA    03D4
03D4:  NOP   
03D6:  BSF    F94.4
03D8:  MOVLW  19
03DA:  MOVWF  00
03DC:  DECFSZ 00,F
03DE:  BRA    03DC
....................        delay_ms(10);
03E0:  MOVLW  0A
03E2:  MOVWF  4A
03E4:  RCALL  01B0
....................        break;
03E6:  GOTO   06BE (RETURN)
....................       }
....................        
....................     void Write_Days()
....................       {
....................        i2c_start();
*
04A6:  BSF    F94.4
04A8:  MOVLW  19
04AA:  MOVWF  00
04AC:  DECFSZ 00,F
04AE:  BRA    04AC
04B0:  BSF    F94.3
04B2:  MOVLW  19
04B4:  MOVWF  00
04B6:  DECFSZ 00,F
04B8:  BRA    04B6
04BA:  BCF    F8B.4
04BC:  BCF    F94.4
04BE:  MOVLW  19
04C0:  MOVWF  00
04C2:  DECFSZ 00,F
04C4:  BRA    04C2
04C6:  BCF    F8B.3
04C8:  BCF    F94.3
....................        i2c_write(0xD0); //base address ds1307
04CA:  MOVLW  D0
04CC:  MOVWF  49
04CE:  RCALL  031E
....................        i2c_write(0x03); //days reg address
04D0:  MOVLW  03
04D2:  MOVWF  49
04D4:  RCALL  031E
....................        i2c_write(day);  //set days reg to this value
04D6:  MOVFF  0B,49
04DA:  RCALL  031E
....................        i2c_stop(); 
04DC:  BCF    F94.4
04DE:  NOP   
04E0:  BSF    F94.3
04E2:  BTFSS  F82.3
04E4:  BRA    04E2
04E6:  MOVLW  19
04E8:  MOVWF  00
04EA:  DECFSZ 00,F
04EC:  BRA    04EA
04EE:  BRA    04F0
04F0:  NOP   
04F2:  BSF    F94.4
04F4:  MOVLW  19
04F6:  MOVWF  00
04F8:  DECFSZ 00,F
04FA:  BRA    04F8
....................        delay_ms(10);
04FC:  MOVLW  0A
04FE:  MOVWF  4A
0500:  RCALL  01B0
....................        break;
0502:  GOTO   084C (RETURN)
....................       }
.................... 
....................     void Write_Date()
....................       {
....................        i2c_start();
*
0566:  BSF    F94.4
0568:  MOVLW  19
056A:  MOVWF  00
056C:  DECFSZ 00,F
056E:  BRA    056C
0570:  BSF    F94.3
0572:  MOVLW  19
0574:  MOVWF  00
0576:  DECFSZ 00,F
0578:  BRA    0576
057A:  BCF    F8B.4
057C:  BCF    F94.4
057E:  MOVLW  19
0580:  MOVWF  00
0582:  DECFSZ 00,F
0584:  BRA    0582
0586:  BCF    F8B.3
0588:  BCF    F94.3
....................        i2c_write(0xD0); //base address ds1307
058A:  MOVLW  D0
058C:  MOVWF  49
058E:  RCALL  031E
....................        i2c_write(0x04); //date reg address
0590:  MOVLW  04
0592:  MOVWF  49
0594:  RCALL  031E
....................        i2c_write(date); //set date reg to this value
0596:  MOVFF  08,49
059A:  RCALL  031E
....................        i2c_stop(); 
059C:  BCF    F94.4
059E:  NOP   
05A0:  BSF    F94.3
05A2:  BTFSS  F82.3
05A4:  BRA    05A2
05A6:  MOVLW  19
05A8:  MOVWF  00
05AA:  DECFSZ 00,F
05AC:  BRA    05AA
05AE:  BRA    05B0
05B0:  NOP   
05B2:  BSF    F94.4
05B4:  MOVLW  19
05B6:  MOVWF  00
05B8:  DECFSZ 00,F
05BA:  BRA    05B8
....................        delay_ms(10);
05BC:  MOVLW  0A
05BE:  MOVWF  4A
05C0:  RCALL  01B0
....................        break;
05C2:  GOTO   09B0 (RETURN)
....................       }
.................... 
....................     void Write_Months()
....................       {
....................        i2c_start();
*
0506:  BSF    F94.4
0508:  MOVLW  19
050A:  MOVWF  00
050C:  DECFSZ 00,F
050E:  BRA    050C
0510:  BSF    F94.3
0512:  MOVLW  19
0514:  MOVWF  00
0516:  DECFSZ 00,F
0518:  BRA    0516
051A:  BCF    F8B.4
051C:  BCF    F94.4
051E:  MOVLW  19
0520:  MOVWF  00
0522:  DECFSZ 00,F
0524:  BRA    0522
0526:  BCF    F8B.3
0528:  BCF    F94.3
....................        i2c_write(0xD0); //base address ds1307
052A:  MOVLW  D0
052C:  MOVWF  49
052E:  RCALL  031E
....................        i2c_write(0x05); //months reg address
0530:  MOVLW  05
0532:  MOVWF  49
0534:  RCALL  031E
....................        i2c_write(month);//set months reg to this value
0536:  MOVFF  09,49
053A:  RCALL  031E
....................        i2c_stop(); 
053C:  BCF    F94.4
053E:  NOP   
0540:  BSF    F94.3
0542:  BTFSS  F82.3
0544:  BRA    0542
0546:  MOVLW  19
0548:  MOVWF  00
054A:  DECFSZ 00,F
054C:  BRA    054A
054E:  BRA    0550
0550:  NOP   
0552:  BSF    F94.4
0554:  MOVLW  19
0556:  MOVWF  00
0558:  DECFSZ 00,F
055A:  BRA    0558
....................        delay_ms(10);
055C:  MOVLW  0A
055E:  MOVWF  4A
0560:  RCALL  01B0
....................        break;
0562:  GOTO   0902 (RETURN)
....................       }
....................   
....................     void Write_Years()
....................       {
....................        i2c_start();
....................        i2c_write(0xD0); //base address ds1307
....................        i2c_write(0x06); //year reg address
....................        i2c_write(year); //set year reg to this value
....................        i2c_stop();
....................        delay_ms(10);
....................       }
....................   
....................     void Read_All_RTC_Regs() 
....................       { 
....................        i2c_start();                  // Start I2C protocol
....................        i2c_write(0xD0);              // DS1307 address
....................        i2c_write(0);                 // Send register address
....................        i2c_start();                  // Restart I2C
....................        i2c_write(0xD1);              // Initialize data read
....................        second = i2c_read(1);         // Read seconds from register 0
....................        minute = i2c_read(1);         // Read minutes from register 1
....................        hour   = i2c_read(1);         // Read hour from register 2
....................        day    = i2c_read(1);         // Read day from register 3
....................        date   = i2c_read(1);         // Read date from register 4
....................        month  = i2c_read(1);         // Read month from register 5
....................        year   = i2c_read(0);         // Read year from register 6
....................        i2c_stop();                   // Stop I2C protocol
....................        ds1307_display();             // Display time & calendar
....................        delay_ms(100);                // This delay stops the LCD fom flashing
....................       }//end read_All_RTC_Regs       
....................       
....................     void Read_All_RTC_Regs_At_Start() //read all ds1307 regs without display
....................       { 
....................        i2c_start();                  // Start I2C protocol
....................        i2c_write(0xD0);              // DS1307 address
....................        i2c_write(0);                 // Send register address
....................        i2c_start();                  // Restart I2C
....................        i2c_write(0xD1);              // Initialize data read
....................        second = i2c_read(1);         // Read seconds from register 0
....................        minute = i2c_read(1);         // Read minuts from register 1
....................        hour   = i2c_read(1);         // Read hour from register 2
....................        day    = i2c_read(1);         // Read day from register 3
....................        date   = i2c_read(1);         // Read date from register 4
....................        month  = i2c_read(1);         // Read month from register 5
....................        year   = i2c_read(0);         // Read year from register 6
....................        i2c_stop(); // Stop I2C protocol
....................        delay_ms(10);                // This delay stops the LCD fom flashing
....................       }//end read_All_RTC_Regs_At_Start    
....................       
....................   
.................... 
....................         #include <manual_set_time.h>
.................... 
....................     
....................       
.................... 
....................    
....................    /// This file is used to read the thumbwheel switch and 3 push buttons  /// 
....................    /// Start PB Increment PB Save PB                                       ///
....................    /// The seconds are zeroed when the minutes are entered                 ///
....................    ///                                                                     ///
....................    /// All the inputs are pulled up high so all the true input data is     ///
....................    /// tested as Low = true. Only the first 3 bits of the thumbwheel       ///
....................    /// switch are being used that allows for 8 different selections only   ///
....................    /// 5 are being used hours, minutes, day, month, and date               ///
....................    
....................   
....................    /// The day-of-week register in the DS1307 counts from 1 through 7      /// 
....................    /// It doesn't know anything about Sunday, Monday, etc.  It's just a    ///
....................    /// counter that is incremented every day at midnight.                  ///
....................    /// If you want the first day of the week to be Sunday and today is     ///
....................    /// Sunday set the day-of-week to the value 1.  If today is Monday set  ///
....................    /// the day-of-week to the value 2, etc.Then every time you read the    ///
....................    /// day of week from the DS1307 1 ==> Sunday 2 ==> Monday etc           ///
....................    ///                                                                     ///
....................    
....................    
....................     
....................       #define PB_increment pin_B4
....................       #define PB_Save_Time pin_B5
....................       
....................      
....................       int loop5 = 0;
....................       int value;
....................       int temp =0;
....................       
....................     void Template()
....................        {                                     
....................                 putc (0xfe); 
*
01F8:  MOVLW  FE
01FA:  RCALL  01A8
....................                 putc (0x45); // psn cmd
01FC:  MOVLW  45
01FE:  RCALL  01A8
....................                 putc (0x05); // psn                
0200:  MOVLW  05
0202:  RCALL  01A8
....................                 printf ("WB9IXS UTC");                
0204:  MOVLW  50
0206:  MOVWF  FF6
0208:  MOVLW  00
020A:  MOVWF  FF7
020C:  RCALL  01D6
....................                 putc (0xfe); 
020E:  MOVLW  FE
0210:  RCALL  01A8
....................                 putc (0x45); // psn cmd
0212:  MOVLW  45
0214:  RCALL  01A8
....................                 putc (0x47); // psn 
0216:  MOVLW  47
0218:  RCALL  01A8
....................                 printf ("CLOCK");                 
021A:  MOVLW  5C
021C:  MOVWF  FF6
021E:  MOVLW  00
0220:  MOVWF  FF7
0222:  RCALL  01D6
....................                 putc (0xfe); 
0224:  MOVLW  FE
0226:  RCALL  01A8
....................                 putc (0x45); // psn cmd
0228:  MOVLW  45
022A:  RCALL  01A8
....................                 putc (0x14); //row1 
022C:  MOVLW  14
022E:  RCALL  01A8
....................                 printf ("UT   :  ");                
0230:  MOVLW  62
0232:  MOVWF  FF6
0234:  MOVLW  00
0236:  MOVWF  FF7
0238:  RCALL  01D6
....................                 putc (0xfe); 
023A:  MOVLW  FE
023C:  RCALL  01A8
....................                 putc (0x45); // psn cmd
023E:  MOVLW  45
0240:  RCALL  01A8
....................                 putc (0x1d); //row1 
0242:  MOVLW  1D
0244:  RCALL  01A8
....................                 printf ("CT   :  :  ");
0246:  MOVLW  6C
0248:  MOVWF  FF6
024A:  MOVLW  00
024C:  MOVWF  FF7
024E:  RCALL  01D6
0250:  RETURN 0
....................                }    
....................              
....................     void Manual_Set_Time() {
....................                 loop5 = 1; 
*
05C6:  MOVLW  01
05C8:  MOVWF  0F
....................                 value = input_b() & 0x07; // only read 1st 3 bits
05CA:  SETF   F93
05CC:  MOVF   F81,W
05CE:  ANDLW  07
05D0:  MOVWF  10
....................                 delay_ms(500);                                                  
05D2:  MOVLW  02
05D4:  MOVWF  49
05D6:  MOVLW  FA
05D8:  MOVWF  4A
05DA:  RCALL  01B0
05DC:  DECFSZ 49,F
05DE:  BRA    05D6
....................     /* Value is the value read from the 1st 3 bits on the thumbwheel switch */
....................     /* Because the inputs are pulled high the values are inverted. for example*/
....................     /* PSN 0 has no contacts pulled low so the value is 0x07 PSN 1 has bit 0 */
....................     /* low so the value is 0x06 psn 2 has bit 2 low so the value is 0x05 and */
....................     /* so on                                                                 */
....................     
....................     
....................          switch(value ) {            
05E0:  MOVF   10,W
05E2:  XORLW  07
05E4:  BZ    0600
05E6:  XORLW  01
05E8:  BTFSC  FD8.2
05EA:  BRA    06D6
05EC:  XORLW  03
05EE:  BTFSC  FD8.2
05F0:  BRA    0798
05F2:  XORLW  01
05F4:  BTFSC  FD8.2
05F6:  BRA    0864
05F8:  XORLW  07
05FA:  BTFSC  FD8.2
05FC:  BRA    091A
05FE:  BRA    09CE
....................             case 7: //hour
....................                   temp=1;
0600:  MOVLW  01
0602:  MOVWF  11
....................                   putc (0xfe);
0604:  MOVLW  FE
0606:  RCALL  01A8
....................                   putc (0x51); // clear the screen
0608:  MOVLW  51
060A:  RCALL  01A8
....................                while(loop5){
060C:  MOVF   0F,F
060E:  BTFSC  FD8.2
0610:  BRA    06D6
....................                  putc (0xFE);
0612:  MOVLW  FE
0614:  RCALL  01A8
....................                  putc (0x45);  // cursor psn cmd
0616:  MOVLW  45
0618:  RCALL  01A8
....................                  putc (0x00);  // cursor psn 
061A:  MOVLW  00
061C:  RCALL  01A8
....................                  printf("Hrs are 24hr format");
061E:  MOVLW  78
0620:  MOVWF  FF6
0622:  MOVLW  00
0624:  MOVWF  FF7
0626:  RCALL  01D6
....................                  putc (0xFE);
0628:  MOVLW  FE
062A:  RCALL  01A8
....................                  putc (0x45);  // cursor psn cmd
062C:  MOVLW  45
062E:  RCALL  01A8
....................                  putc (0x40);  // cursor psn 
0630:  MOVLW  40
0632:  RCALL  01A8
....................                  printf("Hrs are CT time UTC");
0634:  MOVLW  8C
0636:  MOVWF  FF6
0638:  MOVLW  00
063A:  MOVWF  FF7
063C:  RCALL  01D6
....................                  putc (0xFE);
063E:  MOVLW  FE
0640:  RCALL  01A8
....................                  putc (0x45);  // cursor psn cmd
0642:  MOVLW  45
0644:  RCALL  01A8
....................                  putc (0x14);  // cursor psn 
0646:  MOVLW  14
0648:  RCALL  01A8
....................                  printf("time is automatic");
064A:  MOVLW  A0
064C:  MOVWF  FF6
064E:  MOVLW  00
0650:  MOVWF  FF7
0652:  RCALL  01D6
....................          // print the hours as they increment    
....................                 putc (0xFE);
0654:  MOVLW  FE
0656:  RCALL  01A8
....................                 putc (0x45);  // cursor psn cmd
0658:  MOVLW  45
065A:  RCALL  01A8
....................                 putc (0x54);  // cursor psn       
065C:  MOVLW  54
065E:  RCALL  01A8
....................                 printf (" Hours =-> %u",temp);
0660:  MOVLW  B2
0662:  MOVWF  FF6
0664:  MOVLW  00
0666:  MOVWF  FF7
0668:  MOVLW  0B
066A:  MOVWF  49
066C:  RCALL  026A
066E:  MOVFF  11,49
0672:  MOVLW  1B
0674:  MOVWF  4A
0676:  RCALL  02B2
....................                 delay_ms(100);
0678:  MOVLW  64
067A:  MOVWF  4A
067C:  RCALL  01B0
....................                   
....................                   if(!input(PB_increment)){temp ++;delay_ms(200);}
067E:  BSF    F93.4
0680:  BTFSC  F81.4
0682:  BRA    068C
0684:  INCF   11,F
0686:  MOVLW  C8
0688:  MOVWF  4A
068A:  RCALL  01B0
....................                      if (temp > 24){temp = 0;}
068C:  MOVF   11,W
068E:  SUBLW  18
0690:  BC    0694
0692:  CLRF   11
....................                         if(!input(PB_Save_Time)){
0694:  BSF    F93.5
0696:  BTFSC  F81.5
0698:  BRA    06D4
....................                         hour = (((temp/10) << 4) | (temp % 10));
069A:  MOVFF  11,4B
069E:  MOVLW  0A
06A0:  MOVWF  4C
06A2:  RCALL  028A
06A4:  SWAPF  01,W
06A6:  MOVWF  49
06A8:  MOVLW  F0
06AA:  ANDWF  49,F
06AC:  MOVFF  11,4B
06B0:  MOVLW  0A
06B2:  MOVWF  4C
06B4:  RCALL  028A
06B6:  MOVF   00,W
06B8:  IORWF  49,W
06BA:  MOVWF  07
....................                         //(((temp/10) << 4) | (temp % 10)); convert temp to BCD
....................                         Write_hours();
06BC:  BRA    038A
....................                         loop5 = 0;
06BE:  CLRF   0F
....................                         temp=0;
06C0:  CLRF   11
....................                   // clear the area where the hours were setup 
....................                         putc (0xfe);
06C2:  MOVLW  FE
06C4:  RCALL  01A8
....................                         putc (0x51); // clear the screen
06C6:  MOVLW  51
06C8:  RCALL  01A8
....................                         delay_ms(200);
06CA:  MOVLW  C8
06CC:  MOVWF  4A
06CE:  RCALL  01B0
....................                         Template();
06D0:  RCALL  01F8
....................                         return;
06D2:  BRA    09D2
....................                         }//end if 
06D4:  BRA    060C
....................                          }//end while  
....................             
....................             case 6:   //minute
....................                   putc (0xfe);
06D6:  MOVLW  FE
06D8:  RCALL  01A8
....................                   putc (0x51); // clear the screen
06DA:  MOVLW  51
06DC:  RCALL  01A8
....................                while(loop5){
06DE:  MOVF   0F,F
06E0:  BZ    0798
....................                   putc (0xFE);
06E2:  MOVLW  FE
06E4:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
06E6:  MOVLW  45
06E8:  RCALL  01A8
....................                   putc (0x00);  // cursor psn 
06EA:  MOVLW  00
06EC:  RCALL  01A8
....................                   printf("Sec's are set to 0 ");
06EE:  MOVLW  C0
06F0:  MOVWF  FF6
06F2:  MOVLW  00
06F4:  MOVWF  FF7
06F6:  RCALL  01D6
....................                   putc (0xFE);
06F8:  MOVLW  FE
06FA:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
06FC:  MOVLW  45
06FE:  RCALL  01A8
....................                   putc (0x40);  // cursor psn 
0700:  MOVLW  40
0702:  RCALL  01A8
....................                   printf("when min's are saved");
0704:  MOVLW  D4
0706:  MOVWF  FF6
0708:  MOVLW  00
070A:  MOVWF  FF7
070C:  RCALL  01D6
....................                   delay_ms(100);
070E:  MOVLW  64
0710:  MOVWF  4A
0712:  RCALL  01B0
....................             // print the minutes as they increment 
....................                   putc (0xFE);
0714:  MOVLW  FE
0716:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
0718:  MOVLW  45
071A:  RCALL  01A8
....................                   putc (0x54);  // cursor psn   
071C:  MOVLW  54
071E:  RCALL  01A8
....................                   printf (" Minutes =-> %u",temp);
0720:  MOVLW  EA
0722:  MOVWF  FF6
0724:  MOVLW  00
0726:  MOVWF  FF7
0728:  MOVLW  0D
072A:  MOVWF  49
072C:  RCALL  026A
072E:  MOVFF  11,49
0732:  MOVLW  1B
0734:  MOVWF  4A
0736:  RCALL  02B2
....................                   delay_ms(100);
0738:  MOVLW  64
073A:  MOVWF  4A
073C:  RCALL  01B0
....................                  
....................                   if(!input(PB_increment)){temp ++;delay_ms(200);}  
073E:  BSF    F93.4
0740:  BTFSC  F81.4
0742:  BRA    074C
0744:  INCF   11,F
0746:  MOVLW  C8
0748:  MOVWF  4A
074A:  RCALL  01B0
....................                      if (temp > 59){temp = 0;}
074C:  MOVF   11,W
074E:  SUBLW  3B
0750:  BC    0754
0752:  CLRF   11
....................                         if(!input(PB_Save_Time)){
0754:  BSF    F93.5
0756:  BTFSC  F81.5
0758:  BRA    0796
....................                         minute = (((temp/10) << 4) | (temp % 10));
075A:  MOVFF  11,4B
075E:  MOVLW  0A
0760:  MOVWF  4C
0762:  RCALL  028A
0764:  SWAPF  01,W
0766:  MOVWF  49
0768:  MOVLW  F0
076A:  ANDWF  49,F
076C:  MOVFF  11,4B
0770:  MOVLW  0A
0772:  MOVWF  4C
0774:  RCALL  028A
0776:  MOVF   00,W
0778:  IORWF  49,W
077A:  MOVWF  06
....................                         //(((temp/10) << 4) | (temp % 10)); convert temp to BCD
....................                         Write_minutes();
077C:  BRA    03EA
....................                         Write_seconds();
077E:  BRA    044A
....................                         loop5 = 0;
0780:  CLRF   0F
....................                         temp=0;
0782:  CLRF   11
....................             // clear the area where the hours were setup  
....................                         putc (0xfe);
0784:  MOVLW  FE
0786:  RCALL  01A8
....................                         putc (0x51); // clear the screen
0788:  MOVLW  51
078A:  RCALL  01A8
....................                         delay_ms(200);
078C:  MOVLW  C8
078E:  MOVWF  4A
0790:  RCALL  01B0
....................                         Template();
0792:  RCALL  01F8
....................                         return;
0794:  BRA    09D2
....................                        }//end if
0796:  BRA    06DE
....................                        }//end while 
....................                        
....................            case 5:   //day
....................                   temp=1;
0798:  MOVLW  01
079A:  MOVWF  11
....................                   putc (0xfe);
079C:  MOVLW  FE
079E:  RCALL  01A8
....................                   putc (0x51); // clear the screen
07A0:  MOVLW  51
07A2:  RCALL  01A8
....................                   delay_ms(200);
07A4:  MOVLW  C8
07A6:  MOVWF  4A
07A8:  RCALL  01B0
....................                while(loop5){
07AA:  MOVF   0F,F
07AC:  BZ    0864
....................                   putc (0xFE);
07AE:  MOVLW  FE
07B0:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
07B2:  MOVLW  45
07B4:  RCALL  01A8
....................                   putc (0x0);  // cursor psn 
07B6:  MOVLW  00
07B8:  RCALL  01A8
....................                   printf ("1=Sun2=Mon3=Tue4=Wed");
07BA:  MOVLW  FA
07BC:  MOVWF  FF6
07BE:  MOVLW  00
07C0:  MOVWF  FF7
07C2:  RCALL  01D6
....................                   putc (0xFE);
07C4:  MOVLW  FE
07C6:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
07C8:  MOVLW  45
07CA:  RCALL  01A8
....................                   putc (0x40);  // cursor psn 
07CC:  MOVLW  40
07CE:  RCALL  01A8
....................                   printf ("5=Thu6=Fri7=Sat");
07D0:  MOVLW  10
07D2:  MOVWF  FF6
07D4:  MOVLW  01
07D6:  MOVWF  FF7
07D8:  RCALL  01D6
....................             // print the day as they increment 
....................                   putc (0xFE);
07DA:  MOVLW  FE
07DC:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
07DE:  MOVLW  45
07E0:  RCALL  01A8
....................                   putc (0x54);  // cursor psn   
07E2:  MOVLW  54
07E4:  RCALL  01A8
....................                   printf ("Day =->%u",temp);
07E6:  MOVLW  20
07E8:  MOVWF  FF6
07EA:  MOVLW  01
07EC:  MOVWF  FF7
07EE:  MOVLW  07
07F0:  MOVWF  49
07F2:  RCALL  026A
07F4:  MOVFF  11,49
07F8:  MOVLW  1B
07FA:  MOVWF  4A
07FC:  RCALL  02B2
....................                   delay_ms(100);
07FE:  MOVLW  64
0800:  MOVWF  4A
0802:  RCALL  01B0
....................                  
....................                   if(!input(PB_increment)){temp ++;delay_ms(300);}  
0804:  BSF    F93.4
0806:  BTFSC  F81.4
0808:  BRA    081A
080A:  INCF   11,F
080C:  MOVLW  02
080E:  MOVWF  49
0810:  MOVLW  96
0812:  MOVWF  4A
0814:  RCALL  01B0
0816:  DECFSZ 49,F
0818:  BRA    0810
....................                      if (temp > 7){temp = 0;}
081A:  MOVF   11,W
081C:  SUBLW  07
081E:  BC    0822
0820:  CLRF   11
....................                         if(!input(PB_Save_Time)){
0822:  BSF    F93.5
0824:  BTFSC  F81.5
0826:  BRA    0862
....................                         day = (((temp/10) << 4) | (temp % 10));
0828:  MOVFF  11,4B
082C:  MOVLW  0A
082E:  MOVWF  4C
0830:  RCALL  028A
0832:  SWAPF  01,W
0834:  MOVWF  49
0836:  MOVLW  F0
0838:  ANDWF  49,F
083A:  MOVFF  11,4B
083E:  MOVLW  0A
0840:  MOVWF  4C
0842:  RCALL  028A
0844:  MOVF   00,W
0846:  IORWF  49,W
0848:  MOVWF  0B
....................                         //(((temp/10) << 4) | (temp % 10)); convert temp to BCD
....................                         Write_days();
084A:  BRA    04A6
....................                         loop5 = 0;
084C:  CLRF   0F
....................                         temp=0;
084E:  CLRF   11
....................             // clear the area where the hours were setup     
....................                          putc (0xfe);
0850:  MOVLW  FE
0852:  RCALL  01A8
....................                          putc (0x51); // clear the screen
0854:  MOVLW  51
0856:  RCALL  01A8
....................                          delay_ms(200);
0858:  MOVLW  C8
085A:  MOVWF  4A
085C:  RCALL  01B0
....................                          Template();
085E:  RCALL  01F8
....................                         return;
0860:  BRA    09D2
....................                        }//end if
0862:  BRA    07AA
....................                        }//end while 
....................                        
....................             case 4:   //month
....................                   temp=1;
0864:  MOVLW  01
0866:  MOVWF  11
....................                   putc (0xfe);
0868:  MOVLW  FE
086A:  RCALL  01A8
....................                   putc (0x51); // clear the screen
086C:  MOVLW  51
086E:  RCALL  01A8
....................                   delay_ms(200);
0870:  MOVLW  C8
0872:  MOVWF  4A
0874:  RCALL  01B0
....................                while(loop5){
0876:  MOVF   0F,F
0878:  BZ    091A
....................                   putc (0xFE);
087A:  MOVLW  FE
087C:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
087E:  MOVLW  45
0880:  RCALL  01A8
....................                   putc (0x0);  // cursor psn 
0882:  MOVLW  00
0884:  RCALL  01A8
....................                   printf ("Enter month 1-12");
0886:  MOVLW  2A
0888:  MOVWF  FF6
088A:  MOVLW  01
088C:  MOVWF  FF7
088E:  RCALL  01D6
....................                   
....................             // print the day as they increment 
....................                   putc (0xFE);
0890:  MOVLW  FE
0892:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
0894:  MOVLW  45
0896:  RCALL  01A8
....................                   putc (0x54);  // cursor psn   
0898:  MOVLW  54
089A:  RCALL  01A8
....................                   printf (" Month =->%u",temp);
089C:  MOVLW  3C
089E:  MOVWF  FF6
08A0:  MOVLW  01
08A2:  MOVWF  FF7
08A4:  MOVLW  0A
08A6:  MOVWF  49
08A8:  RCALL  026A
08AA:  MOVFF  11,49
08AE:  MOVLW  1B
08B0:  MOVWF  4A
08B2:  RCALL  02B2
....................                   delay_ms(100);
08B4:  MOVLW  64
08B6:  MOVWF  4A
08B8:  RCALL  01B0
....................                  
....................                   if(!input(PB_increment)){temp ++;delay_ms(300);}  
08BA:  BSF    F93.4
08BC:  BTFSC  F81.4
08BE:  BRA    08D0
08C0:  INCF   11,F
08C2:  MOVLW  02
08C4:  MOVWF  49
08C6:  MOVLW  96
08C8:  MOVWF  4A
08CA:  RCALL  01B0
08CC:  DECFSZ 49,F
08CE:  BRA    08C6
....................                      if (temp > 12){temp = 0;}
08D0:  MOVF   11,W
08D2:  SUBLW  0C
08D4:  BC    08D8
08D6:  CLRF   11
....................                         if(!input(PB_Save_Time)){
08D8:  BSF    F93.5
08DA:  BTFSC  F81.5
08DC:  BRA    0918
....................                         month = (((temp/10) << 4) | (temp % 10));
08DE:  MOVFF  11,4B
08E2:  MOVLW  0A
08E4:  MOVWF  4C
08E6:  RCALL  028A
08E8:  SWAPF  01,W
08EA:  MOVWF  49
08EC:  MOVLW  F0
08EE:  ANDWF  49,F
08F0:  MOVFF  11,4B
08F4:  MOVLW  0A
08F6:  MOVWF  4C
08F8:  RCALL  028A
08FA:  MOVF   00,W
08FC:  IORWF  49,W
08FE:  MOVWF  09
....................                         //(((temp/10) << 4) | (temp % 10)); convert temp to BCD
....................                         Write_months();
0900:  BRA    0506
....................                         loop5 = 0;
0902:  CLRF   0F
....................                         temp=0;
0904:  CLRF   11
....................             // clear the area where the hours were setup     
....................                          putc (0xfe);
0906:  MOVLW  FE
0908:  RCALL  01A8
....................                          putc (0x51); // clear the screen
090A:  MOVLW  51
090C:  RCALL  01A8
....................                          delay_ms(200);
090E:  MOVLW  C8
0910:  MOVWF  4A
0912:  RCALL  01B0
....................                          Template();
0914:  RCALL  01F8
....................                         return;
0916:  BRA    09D2
....................                        }//end if
0918:  BRA    0876
....................                        }//end while 
....................                        
....................            case 3:   //date
....................                   temp=1;
091A:  MOVLW  01
091C:  MOVWF  11
....................                   putc (0xfe);
091E:  MOVLW  FE
0920:  RCALL  01A8
....................                   putc (0x51); // clear the screen
0922:  MOVLW  51
0924:  RCALL  01A8
....................                   delay_ms(200);
0926:  MOVLW  C8
0928:  MOVWF  4A
092A:  RCALL  01B0
....................                while(loop5){
092C:  MOVF   0F,F
092E:  BZ    09CE
....................                   putc (0xFE);
0930:  MOVLW  FE
0932:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
0934:  MOVLW  45
0936:  RCALL  01A8
....................                   putc (0x0);  // cursor psn 
0938:  MOVLW  00
093A:  RCALL  01A8
....................                   printf ("Enter Date 1-31");
093C:  MOVLW  4A
093E:  MOVWF  FF6
0940:  MOVLW  01
0942:  MOVWF  FF7
0944:  RCALL  01D6
....................                   
....................             // print the day as they increment 
....................                   putc (0xFE);
0946:  MOVLW  FE
0948:  RCALL  01A8
....................                   putc (0x45);  // cursor psn cmd
094A:  MOVLW  45
094C:  RCALL  01A8
....................                   putc (0x54);  // cursor psn   
094E:  MOVLW  54
0950:  RCALL  01A8
....................                   printf (" Date =->%u",temp);
0952:  MOVLW  5A
0954:  MOVWF  FF6
0956:  MOVLW  01
0958:  MOVWF  FF7
095A:  MOVLW  09
095C:  MOVWF  49
095E:  RCALL  026A
0960:  MOVFF  11,49
0964:  MOVLW  1B
0966:  MOVWF  4A
0968:  RCALL  02B2
....................                   delay_ms(100);
096A:  MOVLW  64
096C:  MOVWF  4A
096E:  RCALL  01B0
....................                  
....................                   if(!input(PB_increment)){temp ++;delay_ms(200);}  
0970:  BSF    F93.4
0972:  BTFSC  F81.4
0974:  BRA    097E
0976:  INCF   11,F
0978:  MOVLW  C8
097A:  MOVWF  4A
097C:  RCALL  01B0
....................                      if (temp > 31){temp = 0;}
097E:  MOVF   11,W
0980:  SUBLW  1F
0982:  BC    0986
0984:  CLRF   11
....................                         if(!input(PB_Save_Time)){
0986:  BSF    F93.5
0988:  BTFSC  F81.5
098A:  BRA    09CC
....................                         date = (((temp/10) << 4) | (temp % 10));
098C:  MOVFF  11,4B
0990:  MOVLW  0A
0992:  MOVWF  4C
0994:  RCALL  028A
0996:  SWAPF  01,W
0998:  MOVWF  49
099A:  MOVLW  F0
099C:  ANDWF  49,F
099E:  MOVFF  11,4B
09A2:  MOVLW  0A
09A4:  MOVWF  4C
09A6:  RCALL  028A
09A8:  MOVF   00,W
09AA:  IORWF  49,W
09AC:  MOVWF  08
....................                         //(((temp/10) << 4) | (temp % 10)); convert temp to BCD
....................                         Write_date();
09AE:  BRA    0566
....................                         loop5 = 0;
09B0:  CLRF   0F
....................                         temp=0;
09B2:  CLRF   11
....................             // clear the area where the hours were setup     
....................                          putc (0xfe);
09B4:  MOVLW  FE
09B6:  CALL   01A8
....................                          putc (0x51); // clear the screen
09BA:  MOVLW  51
09BC:  CALL   01A8
....................                          delay_ms(200);
09C0:  MOVLW  C8
09C2:  MOVWF  4A
09C4:  CALL   01B0
....................                          Template();
09C8:  RCALL  01F8
....................                         return;
09CA:  BRA    09D2
....................                        }//end if
09CC:  BRA    092C
....................                        }//end while 
....................             default: 
....................                loop5 = 0;
09CE:  CLRF   0F
....................                temp=0;
09D0:  CLRF   11
....................                RETURN;
....................           }//end switch case  
09D2:  GOTO   0B00 (RETURN)
....................       }//end set time
....................      
.................... 
....................         #include <Display_All.h>
....................  
....................  
....................  
....................  
....................     void  Display_All_Regs() {
....................        // Convert BCD to decimal
....................         second = (second >> 4) * 10 + (second & 0x0F);
....................         minute = (minute >> 4) * 10 + (minute & 0x0F);
....................         hour =   (hour   >> 4) * 10 + (hour   & 0x0F);
....................         date =   (date   >> 4) * 10 + (date   & 0x0F);
....................         month =  (month  >> 4) * 10 + (month  & 0x0F);
....................         year =   (year   >> 4) * 10 + (year   & 0x0F);
....................      // End conversion
....................     
....................        
....................          putc (0x1B);  // cursor escape
....................          putc (0x00);
....................          printf ("Hours->%u",hour);
....................          delay_ms(50);
....................          
....................          putc (0x1B);  // cursor escape
....................          putc (0x1a); 
....................          printf ("%u",hour);
....................          delay_ms(50);
....................          
....................          putc (0x1B);  // cursor escape
....................          putc (0x09);  
....................          printf (" Min->");
....................          delay_ms(50);
....................          
....................          putc (0x1B);  // cursor escape
....................          putc (0x0f);
....................          printf ("%u ",minute);
....................          delay_ms(2000);
....................     // clear the area where the hours and minutes were displayed    
....................          putc (0x1B);  // cursor escape
....................          putc (0x00);
....................          printf ("  WB9IXS UTC CLOCK  ");
....................          Read_All_RTC_Regs();
....................       
....................     }
.................... 
....................         #include <AutoSetTime.h>
.................... int Time=0;
.................... 
.................... void SetDate(int MyDay)
.................... {
....................    date = (((MyDay/10) << 4) | (temp % 10));
....................    Write_date();
....................    
.................... }
.................... 
.................... 
.................... 
....................         #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
....................         #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
....................         #include <input.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                             input.c                               ////
.................... ////                                                                   ////
.................... //// Routines for reading user input over an RS232 stream.  User input ////
.................... //// is in ASCII form and converted to requested binary or float       ////
.................... //// format.                                                           ////
.................... ////                                                                   ////
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  ////
.................... //// that serial stream.  If not, uses the last #use rs232().          ////
.................... ////                                                                   ////
.................... //// Some of these routines are not available unless you #include      ////
.................... //// string.h and stdlib.h                                             ////
.................... ////                                                                   ////
.................... ////  int8 gethex() - read 2 char hex value from serial                ////
.................... ////                                                                   ////
.................... ////  get_string(s, max) - read max chars from serial and save to s    ////
.................... ////                                                                   ////
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   ////
.................... ////     displays current string in s, allowing you to edit it.        ////
.................... ////                                                                   ////
.................... ////  int8 = get_Int8() -                                              ////
.................... ////  int16 = get_Int16() -                                            ////
.................... ////  int32 = get_Int32() -                                            ////
.................... ////  float = get_float() -                                            ////
.................... ////     Read value from serial.                                       ////
.................... ////                                                                   ////
.................... ////  int8 = get_Int8Edit(old) -                                       ////
.................... ////  int16 = get_Int16Edit(old) -                                     ////
.................... ////  int32 = get_Int32Edit(old) -                                     ////
.................... ////  float = get_floatEdit(old) -                                     ////
.................... ////     Similar to get_Int*() routines documented above, but first    ////
.................... ////     it displays old value allowing you to edit it.                ////
.................... ////                                                                   ////
.................... ////  int = get_int() -                                                ////
.................... ////  long = get_long() -                                              ////
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   ////
.................... ////     'long' datatypes.  The size of these datatypes depends on     ////
.................... ////     the PIC architecture and compiler configuration.              ////
.................... ////                                                                   ////
.................... ////  int = get_intEdit(old) -                                         ////
.................... ////  long = get_longEdit(old) -                                       ////
.................... ////     Similar to get_int() and get_long() documented above,         ////
.................... ////     but first it displays old value allowing you to edit it.      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __INPUT_C__
.................... #define __INPUT_C__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #ifndef InputKbhit
....................    #if defined(STREAM_SERIAL_INPUT)
....................       #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT)
....................    #else
....................       #define InputKbhit()    kbhit()
....................    #endif
.................... #endif
.................... 
.................... #if !definedinc(InputPutc)
....................    #if defined(STREAM_SERIAL_INPUT)
....................       void InputPutc(char c)    {fputc(c, STREAM_SERIAL_INPUT);}
....................    #else
....................       void InputPutc(char c)    {putc(c);}
....................    #endif
.................... #endif
.................... 
.................... #ifndef InputGetc
....................    #if defined(STREAM_SERIAL_INPUT)
....................       #define InputGetc()    fgetc(STREAM_SERIAL_INPUT)
....................    #else
....................       #define InputGetc()    getc()
....................    #endif
.................... #endif
.................... 
.................... unsigned int8 gethex1() {
....................    char digit;
.................... 
....................    digit = InputGetc();
.................... 
....................    InputPutc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... unsigned int8 gethex() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1();
....................    lo = gethex1();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string(char* s, unsigned int8 max) {
....................    unsigned int8 len;
....................    char c;
.................... 
....................    max-=2;
....................    len=0;
....................    do {
....................      c=InputGetc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           InputPutc(c);
....................           InputPutc(' ');
....................           InputPutc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<=max) {
....................          s[len++]=c;
....................          InputPutc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... #ifdef _STRING
.................... void get_stringEdit(char* s, unsigned int8 max) {
....................    unsigned int8 len;
....................    char c;
.................... 
....................    len = strlen(s);
.................... 
....................    if (len)
....................    {
....................      #if defined(STREAM_SERIAL_INPUT)
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s);
....................      #else
....................       printf(InputPutc, "%s", s);
....................      #endif
....................    }
.................... 
....................    max-=2;
.................... 
....................    do {
....................      c=InputGetc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           InputPutc(c);
....................           InputPutc(' ');
....................           InputPutc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<=max) {
....................          s[len++]=c;
....................          InputPutc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... #endif
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... signed int8 get_Int8(void)
.................... {
....................   char s[5];
....................   signed int8 i;
.................... 
....................   get_string(s, sizeof(s));
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int8 get_Int8Edit(signed int8 old)
.................... {
....................   char s[5];
....................   signed int8 i;
.................... 
....................   sprintf(s, "%d", old);
....................   get_stringEdit(s, sizeof(s));
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... #endif
.................... 
.................... signed int16 get_Int16(void)
.................... {
....................   char s[7];
....................   signed int16 l;
.................... 
....................   get_string(s, sizeof(s));
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int16 get_Int16Edit(signed int16 old)
.................... {
....................   char s[7];
....................   signed int16 l;
.................... 
....................   sprintf(s, "%ld", old);
.................... 
....................   get_stringEdit(s, sizeof(s));
....................   l=atol(s);
....................   return(l);
.................... }
.................... #endif
.................... 
.................... signed int32 get_Int32(void)
.................... {
....................   char s[12];
....................   signed int32 l;
.................... 
....................   get_string(s, sizeof(s));
....................   l=atoi32(s);
....................   return(l);
.................... }
.................... 
.................... #ifdef _STRING
.................... signed int32 get_Int32Edit(signed int32 old)
.................... {
....................   char s[12];
....................   signed int32 l;
.................... 
....................   sprintf(s, "%ld", old);
.................... 
....................   get_stringEdit(s, sizeof(s));
....................   l=atoi32(s);
....................   return(l);
.................... }
.................... #endif
.................... 
.................... float get_float() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #ifdef _STRING
.................... float get_floatEdit(float old) {
....................   char s[20];
....................   float f;
.................... 
....................   sprintf(s, "%f", old);
.................... 
....................   get_string(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
....................    #define get_int()       get_Int16()
....................    #define get_intEdit()   get_Int16Edit()
....................    #define get_long()      get_Int32()
....................    #define get_longEdit()  get_Int32Edit()
.................... #else
....................    #define get_int()       get_Int8()
....................    #define get_intEdit()   get_Int8Edit()
....................    #define get_long()      get_Int16()
....................    #define get_longEdit()  get_Int16Edit()
.................... #endif
.................... 
.................... #endif   //_STDLIB
.................... 
.................... #endif   //__INPUT_C__
.................... 
.................... 
....................         
.................... 
....................         
....................       
....................         #define PB_Set_Time PIN_B3
....................         
....................         void GetDate(int *RawData[])
....................         {
....................            int MyMonth=RawData;
....................            
....................            printf("month = %d",MyMonth);
....................         }
....................    
.................... 
....................    int append(int* s, char c) {
....................         int len = strlen(s);
....................         s[len] = c;
....................         s[len+1] = '\0';
....................         
....................         return s;
....................    }
....................    
....................    
.................... int hr1;
.................... char buffer [22]={0};  
.................... 
.................... 
....................     void main()
09D6:  CLRF   FF8
09D8:  BCF    FD0.7
09DA:  CLRF   04
09DC:  BSF    FB8.3
09DE:  MOVLW  08
09E0:  MOVWF  FAF
09E2:  MOVLW  02
09E4:  MOVWF  FB0
09E6:  MOVLW  A6
09E8:  MOVWF  FAC
09EA:  MOVLW  90
09EC:  MOVWF  FAB
09EE:  NOP   
09F0:  NOP   
09F2:  CLRF   0E
09F4:  CLRF   0D
09F6:  CLRF   0F
09F8:  CLRF   11
09FA:  CLRF   12
09FC:  MOVF   FC1,W
09FE:  ANDLW  C0
0A00:  IORLW  0F
0A02:  MOVWF  FC1
0A04:  MOVLW  07
0A06:  MOVWF  FB4
0A08:  BRA    0A14
0A0A:  DATA 02,00
0A0C:  DATA 13,00
0A0E:  DATA 00,32
0A10:  DATA 40,16
0A12:  DATA 00,00
0A14:  MOVLW  00
0A16:  MOVWF  FF8
0A18:  MOVLW  0A
0A1A:  MOVWF  FF7
0A1C:  MOVLW  0A
0A1E:  MOVWF  FF6
0A20:  TBLRD*+
0A22:  MOVF   FF5,W
0A24:  MOVWF  00
0A26:  XORLW  00
0A28:  BZ    0A50
0A2A:  TBLRD*+
0A2C:  MOVF   FF5,W
0A2E:  MOVWF  01
0A30:  BTFSC  FE8.7
0A32:  BRA    0A3E
0A34:  ANDLW  3F
0A36:  MOVWF  FEA
0A38:  TBLRD*+
0A3A:  MOVFF  FF5,FE9
0A3E:  BTFSC  01.6
0A40:  TBLRD*+
0A42:  BTFSS  01.6
0A44:  TBLRD*+
0A46:  MOVFF  FF5,FEE
0A4A:  DCFSNZ 00,F
0A4C:  BRA    0A20
0A4E:  BRA    0A42
0A50:  CLRF   FF8
....................        {      
....................        
....................          
....................          
....................   
....................                 putc (0xfe);
0A52:  MOVLW  FE
0A54:  CALL   01A8
....................                 putc (0x61); // rs232 baud  
0A58:  MOVLW  61
0A5A:  CALL   01A8
....................                 putc (0x04); // = 9600
0A5E:  MOVLW  04
0A60:  CALL   01A8
....................                 
....................                 delay_ms(3000);       // wait for lcd to init
0A64:  MOVLW  0C
0A66:  MOVWF  49
0A68:  MOVLW  FA
0A6A:  MOVWF  4A
0A6C:  CALL   01B0
0A70:  DECFSZ 49,F
0A72:  BRA    0A68
....................                 putc (0xfe);
0A74:  MOVLW  FE
0A76:  CALL   01A8
....................                 putc (0x41); // Turn on display
0A7A:  MOVLW  41
0A7C:  CALL   01A8
....................                 
....................                 putc (0xfe);
0A80:  MOVLW  FE
0A82:  CALL   01A8
....................                 putc (0x51); // clear the screen               
0A86:  MOVLW  51
0A88:  CALL   01A8
....................                         
....................                 putc (0xfe); // set briteness 0-8
0A8C:  MOVLW  FE
0A8E:  CALL   01A8
....................                 putc (0x53); 
0A92:  MOVLW  53
0A94:  CALL   01A8
....................                 putc (0x08);              
0A98:  MOVLW  08
0A9A:  CALL   01A8
....................                
....................                 putc (0xfe); // set contrast 0-50
0A9E:  MOVLW  FE
0AA0:  CALL   01A8
....................                 putc (0x52); 
0AA4:  MOVLW  52
0AA6:  CALL   01A8
....................                 putc (39);  
0AAA:  MOVLW  27
0AAC:  CALL   01A8
....................                 
....................                 Template();
0AB0:  CALL   01F8
....................                                              
....................                 //Read_All_RTC_Regs_At_Start(); //read all ds1307 regs without display
....................                 
....................                      //int day[2];
.................... 
.................... 
.................... 
....................        while(true)
....................          {  
.................... 
....................          static char date[25];
....................          static char Tday[2];
....................          static unsigned int pos=0;
....................          char inByte;
....................          //Read_All_RTC_Regs(); put back after testing
....................            if(kbhit())
0AB4:  BTFSS  F9E.5
0AB6:  BRA    0AEC
....................            {
....................                
....................             
....................                fgets(buffer,PCdata);
0AB8:  CLRF   FEA
0ABA:  MOVLW  16
0ABC:  MOVWF  FE9
0ABE:  CLRF   FED
0AC0:  GOTO   0252
0AC4:  MOVFF  01,FEC
0AC8:  MOVLW  0D
0ACA:  SUBWF  FEF,W
0ACC:  BNZ   0AC0
0ACE:  CLRF   FEC
....................                hr1 = buffer[0];
0AD0:  MOVFF  16,15
.................... 
....................                printf("%c\r\n",hr1);
0AD4:  MOVF   15,W
0AD6:  BTFSS  F9E.4
0AD8:  BRA    0AD6
0ADA:  MOVWF  FAD
0ADC:  MOVLW  0D
0ADE:  BTFSS  F9E.4
0AE0:  BRA    0ADE
0AE2:  MOVWF  FAD
0AE4:  MOVLW  0A
0AE6:  BTFSS  F9E.4
0AE8:  BRA    0AE6
0AEA:  MOVWF  FAD
....................            
....................            }
....................             
....................    
....................              
....................       
....................            if(!input(PB_Set_Time))
0AEC:  BSF    F93.3
0AEE:  BTFSC  F81.3
0AF0:  BRA    0B00
....................             {
....................                printf("button HIT!!");
0AF2:  MOVLW  9A
0AF4:  MOVWF  FF6
0AF6:  MOVLW  01
0AF8:  MOVWF  FF7
0AFA:  CALL   01D6
....................                Manual_Set_Time(); // this is where the switch psn is read  
0AFE:  BRA    05C6
....................             } 
....................             else
....................             {
....................             }
0B00:  BRA    0AB4
....................             //printf("while loop\r\n");
....................                        
....................       }//end while
.................... }//main
.................... 
0B02:  BRA    0B02
.................... 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
